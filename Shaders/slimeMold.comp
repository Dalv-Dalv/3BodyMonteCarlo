#version 430
#extension GL_ARB_compute_shader: enable
layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D slimeTexture;
uniform int agentsCount;
uniform int width, height;
uniform float time;
uniform float deltaTime;

const float degToRad = 0.0174532925;
uniform float moveSpeed = 5.0;
uniform float turnSpeed = -5.0;
uniform float trailWeight = 0.5;
uniform float sensorAngleSpacing = 10.0;
uniform float sensorOffsetDist = 45;
const int sensorSize = 1;

struct Agent {
    float posx, posy;
    float angle;
};

layout(std430, binding = 0) buffer Agents {
    Agent agents[];
};

uint hash(uint state) {
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float rand01(uint state) {
    return hash(state) / 4294967295.0;
}

float sense(Agent agent, float angle){
    float sensorAngle = agent.angle + angle;
    vec2 sensorDir = vec2(cos(sensorAngle), sin(sensorAngle));
    ivec2 sensorCenter = ivec2(agent.posx, agent.posy) + ivec2(sensorDir * sensorOffsetDist);
    float sum = 0;

    for(int x = -sensorSize; x <= sensorSize; x++){
        for(int y = -sensorSize; y <= sensorSize; y++){
            ivec2 pos = sensorCenter + ivec2(x, y);
            if(pos.x >= 0 && pos.x < width && pos.y >= 0 && pos.y < height){
                sum += imageLoad(slimeTexture, pos).r;
            }
        }
    }

    return sum;
}

void main() {
    uint i = uint(gl_GlobalInvocationID.x);

    if(i >= agentsCount) return;

    vec2 pos = vec2(agents[i].posx, agents[i].posy);
    float randVal = rand01(uint(pos.y * width + pos.x + time * 1000.0)) * 10.0;

    float weightForward = sense(agents[i], 0);
    float weightLeft = sense(agents[i], sensorAngleSpacing * degToRad);
    float weightRight = sense(agents[i], -sensorAngleSpacing * degToRad);
    if(weightForward > weightLeft && weightForward > weightRight){
        agents[i].angle += 0;
    }else if(weightForward < weightLeft && weightForward < weightRight){
        agents[i].angle += (randVal * 2.0 - 1.0) * turnSpeed * deltaTime * 0.0;
    }else if(weightRight > weightLeft){
        agents[i].angle -= randVal * turnSpeed * deltaTime;
    }else if(weightLeft > weightRight){
        agents[i].angle += randVal * turnSpeed * deltaTime;
    }


    vec2 dir = vec2(cos(agents[i].angle), sin(agents[i].angle));
    vec2 newPos = pos + dir * moveSpeed * deltaTime;
    if(newPos.x < 0 || newPos.x > width){
        newPos.x = min(width - 1, max(0, newPos.x));
        newPos.y = min(height - 1, max(0, newPos.y));
        agents[i].angle = 3.14159 - agents[i].angle;
    }
    if(newPos.y < 0 || newPos.y > height){
        newPos.x = min(width - 1, max(0, newPos.x));
        newPos.y = min(height - 1, max(0, newPos.y));
        agents[i].angle = -agents[i].angle;
    }
    dir = vec2(cos(agents[i].angle), sin(agents[i].angle));
    newPos = pos + dir * moveSpeed * deltaTime;

    vec3 oldTrail = imageLoad(slimeTexture, ivec2(pos)).rgb;
    oldTrail = min(vec3(1), oldTrail + trailWeight * deltaTime);
    imageStore(slimeTexture, ivec2(pos), vec4(oldTrail, 1));

    agents[i].posx = newPos.x;
    agents[i].posy = newPos.y;
}
