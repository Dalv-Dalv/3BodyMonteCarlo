#version 430
#extension GL_ARB_compute_shader: enable
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D visualizationTexture;
uniform int simCount;
uniform int width, height;
uniform float time;
uniform float deltaTime;
uniform float G;
uniform float escapeThreshold; // Distanta

struct Body {
    vec2 pos, vel;
    float mass;
    vec3 col;
};
struct Simulation {
    Body bodies[3];
    int status;
    float pad[3];
};

layout(std430, binding = 0) buffer SimBuffer {
    Simulation simulations[];
};

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= sims.length()) return;

    // Daca simularea a esuat deja, nu mai calculam nimic
    if (sims[idx].status == 0) return;



    vec2 pos0 = simulations[idx].bodies[0].pos;
    vec2 pos1 = simulations[idx].bodies[1].pos;
    vec2 pos2 = simulations[idx].bodies[2].pos;

    vec2 vel0 = simulations[idx].bodies[0].vel;
    vec2 vel1 = simulations[idx].bodies[1].vel;
    vec2 vel2 = simulations[idx].bodies[2].vel;

    vec2 m0 = simulations[idx].bodies[0].mass;
    vec2 m1 = simulations[idx].bodies[1].mass;
    vec2 m2 = simulations[idx].bodies[2].mass;

    if((pos0-pos1).length()<1){
        simulations[idx].status=0;
        return;
    }
    if((pos1-pos2).length()<1){
        simulations[idx].status=0;
        return;
    }
    if((pos0-pos2).length()<1){
        simulations[idx].status=0;
        return;
    }

    vel0+=G*deltaTime*m1/dot((pos1-pos0),(pos1-pos0))*normalize(pos1-pos0);
    vel0+=G*deltaTime*m2/dot((pos2-pos0),(pos2-pos0))*normalize(pos2-pos0);

    vel1+=G*deltaTime*m0/dot((pos0-pos1),(pos0-pos1))*normalize(pos0-pos1);
    vel1+=G*deltaTime*m2/dot((pos2-pos1),(pos2-pos1))*normalize(pos2-pos1);

    vel2+=G*deltaTime*m0/dot((pos0-pos2),(pos0-pos2))*normalize(pos0-pos2);
    vel2+=G*deltaTime*m1/dot((pos1-pos2),(pos1-pos2))*normalize(pos1-pos2);

    simulations[idx].bodies[0].vel = vel0;
    simulations[idx].bodies[1].vel = vel1;
    simulations[idx].bodies[2].vel = vel2;

    simulations[idx].bodies[0].pos += vel0 * deltaTime;
    simulations[idx].bodies[1].pos += vel1 * deltaTime;
    simulations[idx].bodies[2].pos += vel2 * deltaTime;

    imageStore(visualizationTexture, sims[idx].bodies[0].pos, sims[idx].bodies[0].col);
    imageStore(visualizationTexture, sims[idx].bodies[1].pos, sims[idx].bodies[1].col);
    imageStore(visualizationTexture, sims[idx].bodies[2].pos, sims[idx].bodies[2].col);
}
