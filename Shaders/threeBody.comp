#version 430
#extension GL_ARB_compute_shader: enable
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D trailTexture;
layout(rgba32f, binding = 1) uniform image2D bodiesTexture;
uniform int simCount;
uniform int width, height;
uniform float time;
uniform float deltaTime;
uniform float G;
uniform float escapeThreshold; // Distanta
uniform float collisionThreshold; // Distanta
uniform int stepMethod;

struct Body {
    float x, y, vx, vy;
    float mass, r, g, b;
};

struct Simulation {
    Body bodies[3];
    int status; // 1 = activ, 2 = coliziune, 3 = expulzare
    float pad1, pad2, pad3;
};

layout(std430, binding = 0) buffer SimBuffer {
    Simulation simulations[];
};

void drawBodyAt(ivec2 pos, vec4 col) {
    const int radius = 3;
    for(int x = -radius; x <= radius; x++) {
        for(int y = -radius; y <= radius; y++) {
            float sqrDist = x*x + y*y;
            if(sqrDist > radius*radius) continue;

            float distRatio = sqrDist / (radius * radius);
            ivec2 p = pos + ivec2(x, y);

            if(p.x >= 0 && p.x < width && p.y >= 0 && p.y < height){
                imageStore(bodiesTexture, p, vec4(col.rgb, (1.0 - distRatio)));
            }
        }
    }
}

// Functie pentru calcularea acceleratiei unui corp
vec2 getAcceleration(vec2 pos, vec2 otherPos1, vec2 otherPos2, float m1, float m2) {
    float eps = 0.001; // Softening factor
    vec2 r1 = otherPos1 - pos;
    vec2 r2 = otherPos2 - pos;

    vec2 a = G * m1 * r1 / pow(length(r1) + eps, 3.0);
    a += G * m2 * r2 / pow(length(r2) + eps, 3.0);
    return a;
}


void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= simulations.length()) return;

    if (simulations[idx].status != 1) {
        vec2 center = vec2(width, height) / 2.0;
        float scale = min(width, height) / 4.0;
        for(int i=0; i<3; i++) {
            float px = simulations[idx].bodies[i].x;
            float py = simulations[idx].bodies[i].y;

            vec4 color = vec4(simulations[idx].bodies[i].r, simulations[idx].bodies[i].g, simulations[idx].bodies[i].b, 1.0);

            vec2 worldPos = vec2(px, py);
            ivec2 screenPos = ivec2(center + worldPos * scale);

            if(screenPos.x >= 0 && screenPos.x < width && screenPos.y >= 0 && screenPos.y < height) {
                imageStore(trailTexture, screenPos, color);
            }
            drawBodyAt(screenPos, color);
        }
        return;
    }

    vec2 pos0 = vec2(simulations[idx].bodies[0].x, simulations[idx].bodies[0].y);
    vec2 pos1 = vec2(simulations[idx].bodies[1].x, simulations[idx].bodies[1].y);
    vec2 pos2 = vec2(simulations[idx].bodies[2].x, simulations[idx].bodies[2].y);

    vec2 vel0 = vec2(simulations[idx].bodies[0].vx, simulations[idx].bodies[0].vy);
    vec2 vel1 = vec2(simulations[idx].bodies[1].vx, simulations[idx].bodies[1].vy);
    vec2 vel2 = vec2(simulations[idx].bodies[2].vx, simulations[idx].bodies[2].vy);

    float m0 = simulations[idx].bodies[0].mass;
    float m1 = simulations[idx].bodies[1].mass;
    float m2 = simulations[idx].bodies[2].mass;


    //coliziune
    if(length(pos0-pos1) < collisionThreshold || length(pos1-pos2) < collisionThreshold || length(pos0-pos2) < collisionThreshold) {
        simulations[idx].status = 2;
        return;
    }
    //expulzare
    if(length(pos0) > escapeThreshold || length(pos1) > escapeThreshold || length(pos2) > escapeThreshold) {
        simulations[idx].status = 3;
        return;
    }

    vec2 p[3] = {pos0, pos1, pos2};
    vec2 v[3] = {vel0, vel1, vel2};
    float m[3] = {m0, m1, m2};
    vec2 a[3];

    if (stepMethod == 0) {
        // --- EXPLICIT EULER ---
        for(int i=0; i<3; i++) a[i] = getAcceleration(p[i], p[(i+1)%3], p[(i+2)%3], m[(i+1)%3], m[(i+2)%3]);
        for(int i=0; i<3; i++) {
            p[i] += v[i] * deltaTime; // Pozitia folosind viteza veche
            v[i] += a[i] * deltaTime;
        }
    }
    else if (stepMethod == 1) {
        // --- SEMI-IMPLICIT EULER (Euler-Cromer) ---
        for(int i=0; i<3; i++) a[i] = getAcceleration(p[i], p[(i+1)%3], p[(i+2)%3], m[(i+1)%3], m[(i+2)%3]);
        for(int i=0; i<3; i++) {
            v[i] += a[i] * deltaTime; // Update viteza prima data
            p[i] += v[i] * deltaTime; // Update pozitie folosind VITEZA NOUa
        }
    }
    else if (stepMethod == 2) {
        // --- VELOCITY VERLET ---
        vec2 a_old[3];
        for(int i=0; i<3; i++) a_old[i] = getAcceleration(p[i], p[(i+1)%3], p[(i+2)%3], m[(i+1)%3], m[(i+2)%3]);

        // 1. Update pozitie
        for(int i=0; i<3; i++) p[i] += v[i] * deltaTime + 0.5 * a_old[i] * deltaTime * deltaTime;

        // 2. Calcul acceleratie noua (bazata pe pozitiile noi)
        for(int i=0; i<3; i++) a[i] = getAcceleration(p[i], p[(i+1)%3], p[(i+2)%3], m[(i+1)%3], m[(i+2)%3]);

        // 3. Update viteza
        for(int i=0; i<3; i++) v[i] += 0.5 * (a_old[i] + a[i]) * deltaTime;
    }

    // Salvare inapoi in buffer
    for(int i=0; i<3; i++) {
        simulations[idx].bodies[i].x = p[i].x;
        simulations[idx].bodies[i].y = p[i].y;
        simulations[idx].bodies[i].vx = v[i].x;
        simulations[idx].bodies[i].vy = v[i].y;
    }

    vec2 center = vec2(width, height) / 2.0;
    float scale = min(width, height) / 4.0;
    for(int i=0; i<3; i++) {
        float px = simulations[idx].bodies[i].x;
        float py = simulations[idx].bodies[i].y;

        vec4 color = vec4(simulations[idx].bodies[i].r, simulations[idx].bodies[i].g, simulations[idx].bodies[i].b, 1.0);

        vec2 worldPos = vec2(px, py);
        ivec2 screenPos = ivec2(center + worldPos * scale);

        if(screenPos.x >= 0 && screenPos.x < width && screenPos.y >= 0 && screenPos.y < height) {
            imageStore(trailTexture, screenPos, color);
        }
        drawBodyAt(screenPos, color);
    }
}