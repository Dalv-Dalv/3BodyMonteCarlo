#version 430
#extension GL_ARB_compute_shader: enable
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D visualizationTexture;
uniform int simCount;
uniform int width, height;
uniform float time;
uniform float deltaTime;
uniform float G;
uniform float escapeThreshold; // Distanta
uniform float collisionThreshold; // Distanta

struct Body {
    float x, y, vx, vy;
    float mass, r, g, b;
};

struct Simulation {
    Body bodies[3];
    int status; // 1 = activ, 2 = coliziune, 3 = expulzare
    float pad1, pad2, pad3;
};

layout(std430, binding = 0) buffer SimBuffer {
    Simulation simulations[];
};

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= simulations.length()) return;

    if (simulations[idx].status != 1) {
        vec2 center = vec2(width, height) / 2.0;
        float scale = min(width, height) / 4.0;
        for(int i=0; i<3; i++) {
            float px = simulations[idx].bodies[i].x;
            float py = simulations[idx].bodies[i].y;

            vec4 color = vec4(simulations[idx].bodies[i].r, simulations[idx].bodies[i].g, simulations[idx].bodies[i].b, 1.0);

            vec2 worldPos = vec2(px, py);
            ivec2 screenPos = ivec2(center + worldPos * scale);

            if(screenPos.x >= 0 && screenPos.x < width && screenPos.y >= 0 && screenPos.y < height) {
                imageStore(visualizationTexture, screenPos, color);
            }
        }
        return;
    }

    vec2 pos0 = vec2(simulations[idx].bodies[0].x, simulations[idx].bodies[0].y);
    vec2 pos1 = vec2(simulations[idx].bodies[1].x, simulations[idx].bodies[1].y);
    vec2 pos2 = vec2(simulations[idx].bodies[2].x, simulations[idx].bodies[2].y);

    vec2 vel0 = vec2(simulations[idx].bodies[0].vx, simulations[idx].bodies[0].vy);
    vec2 vel1 = vec2(simulations[idx].bodies[1].vx, simulations[idx].bodies[1].vy);
    vec2 vel2 = vec2(simulations[idx].bodies[2].vx, simulations[idx].bodies[2].vy);

    float m0 = simulations[idx].bodies[0].mass;
    float m1 = simulations[idx].bodies[1].mass;
    float m2 = simulations[idx].bodies[2].mass;


    //coliziune
    if(length(pos0-pos1) < collisionThreshold || length(pos1-pos2) < collisionThreshold || length(pos0-pos2) < collisionThreshold) {
        simulations[idx].status = 2;
        return;
    }
    //expulzare
    if(length(pos0) > escapeThreshold || length(pos1) > escapeThreshold || length(pos2) > escapeThreshold) {
        simulations[idx].status = 3;
        return;
    }

    float eps = 0.01;

    vec2 r01 = pos1 - pos0;
    vec2 r02 = pos2 - pos0;
    vec2 r12 = pos2 - pos1;
    vec2 r10 = pos0 - pos1;
    vec2 r20 = pos0 - pos2;
    vec2 r21 = pos1 - pos2;

    vel0 += G * deltaTime * m1 / pow(length(r01) + eps, 3.0) * r01;
    vel0 += G * deltaTime * m2 / pow(length(r02) + eps, 3.0) * r02;

    vel1 += G * deltaTime * m0 / pow(length(r10) + eps, 3.0) * r10;
    vel1 += G * deltaTime * m2 / pow(length(r12) + eps, 3.0) * r12;

    vel2 += G * deltaTime * m1 / pow(length(r21) + eps, 3.0) * r21;
    vel2 += G * deltaTime * m0 / pow(length(r20) + eps, 3.0) * r20;

    simulations[idx].bodies[0].vx = vel0.x;
    simulations[idx].bodies[0].vy = vel0.y;

    simulations[idx].bodies[1].vx = vel1.x;
    simulations[idx].bodies[1].vy = vel1.y;

    simulations[idx].bodies[2].vx = vel2.x;
    simulations[idx].bodies[2].vy = vel2.y;

    simulations[idx].bodies[0].x += (vel0 * deltaTime).x;
    simulations[idx].bodies[0].y += (vel0 * deltaTime).y;

    simulations[idx].bodies[1].x += (vel1 * deltaTime).x;
    simulations[idx].bodies[1].y += (vel1 * deltaTime).y;

    simulations[idx].bodies[2].x += (vel2 * deltaTime).x;
    simulations[idx].bodies[2].y += (vel2 * deltaTime).y;

    vec2 center = vec2(width, height) / 2.0;
    float scale = min(width, height) / 4.0;
    for(int i=0; i<3; i++) {
        float px = simulations[idx].bodies[i].x;
        float py = simulations[idx].bodies[i].y;

        vec4 color = vec4(simulations[idx].bodies[i].r, simulations[idx].bodies[i].g, simulations[idx].bodies[i].b, 1.0);

        vec2 worldPos = vec2(px, py);
        ivec2 screenPos = ivec2(center + worldPos * scale);

        if(screenPos.x >= 0 && screenPos.x < width && screenPos.y >= 0 && screenPos.y < height) {
            imageStore(visualizationTexture, screenPos, color);
        }
    }
}